#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl2,  lPiston,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  rPiston,        sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           brDrive,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port2,           rArm3,         tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rArm2,         tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           rArm1,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           lArm1,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           lArm2,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           lArm3,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           flDrive,       tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port9,           frDrive,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port10,          blDrive,       tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

void arm(int pwr)
{
	motor[rArm1] = motor[rArm2] = motor[rArm3] = motor[lArm1] = motor[lArm2] = motor[lArm3] = pwr;
}

void claw(int status)
{
	SensorValue[lPiston] = SensorValue[rPiston] = status;
}

void drive(int left, int right)
{
	motor[blDrive] = motor[flDrive] = left;
	motor[brDrive] = motor[frDrive] = right;
}

void encoderClear()
{
	SensorValue[I2C_1] = SensorValue[I2C_2] = 0;
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

void mainAuto(bool left)
{

	//clear encoders
	encoderClear();

	//drives forward to the cube
	while (SensorValue[I2C_1] < 800)
	{
		drive(80, 80);
	}
	drive(0, 0);

	//wait 1/4 seconds
	wait10Msec(25);
	//clear encoders
	encoderClear();

	//grab the cube
	claw(0);
	//wait 1/4 seconds
	wait10Msec(25);

	//lift the cube slightly
	while (SensorValue[I2C_2] < 300)
	{
		arm(100);
	}
	arm(25);

	//wait 1/4 seconds
	wait10Msec(25);
	//clear encoders
	encoderClear();

	//drive forward to line up with middle fence
	while (SensorValue[I2C_1] < 200)
	{
		drive(80, 80);
	}
	drive(0, 0);

	//wait 1/4 seconds
	wait10Msec(25);
	//clear encoders
	encoderClear();

	//turn so back faces the fence
	if (left)
	{
		while (SensorValue[I2C_1] < 400)
		{
			drive(80, -80);
		}
		drive(0, 0);
	}
	else
	{
		while (SensorValue[I2C_1] > -400)
		{
			drive(-80, 80);
		}
		drive(0, 0);
	}

	//clear encoders
	encoderClear();
	//wait 1/4 seconds
	wait10Msec(25);

	//drive up to fence and square up
	drive(-80, -80);
	wait10Msec(100);
	drive(0, 0);

	//lift arm, hit middle stars
	while (SensorValue[I2C_2] < 700)
	{
		arm(127);
	}
	arm(0);

	//release cube
	claw(1);

	//wait 1/4 seconds
	wait10Msec(25);

	//bring arm down
	while (SensorValue[I2C_2] > -300)
	{
		arm(-127);
	}
	arm(0);

	encoderClear();

	//drive up to the 3 stars
	while (SensorValue[I2C_1] < 1000)
	{
		drive(127, 127);
	}
	drive(0, 0);

	//wait 1/4 seconds
	wait10Msec(25);
	//clear encoders
	encoderClear();

	//grab the 3 stars
	claw(0);

	//drive backwards slightly
	while (SensorValue[I2C_1] > 800)
	{
		drive(-80, -80);
	}
	drive(0, 0);

	//wait 1/4 seconds
	wait10Msec(25);

	//drive back to the fence and square up
	drive(-80, -80);
	arm(50);
	wait10Msec(200);
	drive(0, 0);

	//clear encoders
	encoderClear();

	//lift arm
	while (SensorValue[I2C_2] < 0)
	{
		arm(127);
	}
	arm(0);

	//release stars
	claw(1);
}

void backAuto(bool left)
{

	//clear encoders
	encoderClear();

	//drive up to back stars
	while (SensorValue[I2C_1] < 1100)
	{
		drive(60, 60);
	}
	drive(0, 0);

	//wait 1/4 seconds
	wait10Msec(25);
	//clear encoders
	encoderClear();

	//grab stars
	claw(0);

	//wait 3/4 seconds
	wait10Msec(75);

	//drive way back
	if (!left)
	{
	while (SensorValue[I2C_1] > -800)
	{
		drive(-100, -50);
	}
	drive(0, 0);
}
else
{
	while (SensorValue[I2C_1] > -800)
	{
		drive(-50, -100);
	}
	drive(0, 0);
}

	//wait 1/4 seconds
	wait10Msec(25);
	//clear encoders
	encoderClear();

	//turn so back faces the fence
	if (left)
	{
		while (SensorValue[I2C_1] < 400)
		{
			drive(80, -80);
		}
		drive(0, 0);
	}
	else
	{
		while (SensorValue[I2C_1] > -400)
		{
			drive(-80, 80);
		}
		drive(0, 0);
	}

	wait10Msec(25);

	//drive backwards slightly
	while (SensorValue[I2C_1] > 800)
	{
		drive(-80, -80);
	}
	drive(0, 0);

	//wait 1/4 seconds
	wait10Msec(25);

	//drive back to the fence and square up
	drive(-80, -80);
	arm(75);
	wait10Msec(100);
	drive(0, 0);

	//clear encoders
	encoderClear();

	//lift arm
	while (SensorValue[I2C_2] < 400)
	{
		arm(127);
	}
	arm(0);

	//release stars
	claw(1);
}

task autonomous()
{
	claw(1);
	wait10Msec(75);
	backAuto(false);
}

task usercontrol()
{
	while (true)
	{
		motor[flDrive] = motor[blDrive] = vexRT[Ch3];
		motor[frDrive] = motor[brDrive] = vexRT[Ch2];

		if (vexRT[Btn5U])
		{
			arm(127);
		}
		else if (vexRT[Btn5D])
		{
			arm(-100);
		}
		else if (SensorValue[I2C_2] > 50 && SensorValue[I2C_2] < 600 && vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)
		{
			arm(25);
		}
		else if (SensorValue[I2C_2] >= 600 && vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0)
		{
			arm(10);
		}
		else
		{
			arm(0);
		}

		if (vexRT[Btn6U])
		{
			claw(0);
		}
		else if (vexRT[Btn6D])
		{
			claw(1);
		}

		if (vexRT[Btn8D])
		{
			encoderClear();
		}

	}
}
