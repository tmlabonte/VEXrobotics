#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  autoButton,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           lbDrive,       tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port2,           lArm,          tmotorVex393, openLoop)
#pragma config(Motor,  port3,           rArm,          tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           rClaw,         tmotorVex393, openLoop)
#pragma config(Motor,  port5,           lClaw,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           rfDrive,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port7,           lMid,          tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port8,           lfDrive,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port9,           rMid,          tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port10,          rbDrive,       tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void encoderclear()
{
	SensorValue[I2C_1] = SensorValue[I2C_2] = SensorValue[I2C_3] = SensorValue[I2C_4] = 0;
}

void drive(int left, int right, int mid)
{
	motor[lbDrive] = motor[lfDrive] = left;
	motor[rbDrive] = motor[rfDrive] = right;
	motor[lMid] = motor[rMid] = mid;
}

void claw(int pwr)
{
	motor[lClaw] = motor[rClaw] = pwr;
}

void arm(int pwr)
{
	motor[lArm] = motor[rArm] = pwr;
}

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

void counter_counter(bool left)
{

	//clear encoders
	encoderclear();

	//drives forward to the cube
	while (SensorValue[I2C_3] < 1400)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();
	//wait 1/4 seconds
	wait10Msec(25);

	//grab the cube
	claw(127);
	//wait 1 second
	wait10Msec(100);

	//if arm crosses itself, uncross
	if (SensorValue[clawPot] > 3700)
	{
		while (SensorValue[clawPot] > 3600)
		{
			claw(-100);
		}
		claw(0);
	}

	//lift the cube slightly
	while (SensorValue[I2C_1] < 300)
	{
		arm(100);
	}
	arm(40);

	//clear encoders
	encoderclear();

	//drive forward to line up with middle fence
	while (SensorValue[I2C_3] < 400)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//turn so back faces the fence
	if (left)
	{
		while (SensorValue[I2C_3] < 700)
		{
			drive(80, -80, 0);
		}
		drive(0, 0, 0);
	}
	else
	{
		while (SensorValue[I2C_3] > -700)
		{
			drive(-80, 80, 0);
		}
		drive(0, 0, 0);
	}

	//clear encoders
	encoderclear();
	//wait 1/4 seconds
	wait10Msec(25);

	//drive up to fence and square up
	drive(-80, -80, 0);
	wait10Msec(175);
	drive(0, 0, 0);

	//lift arm, hit middle stars
	while (SensorValue[I2C_1] < 1250)
	{
		arm(127);
	}
	arm(0);

	//release cube
	while (SensorValue[clawPot] > 2200)
	{
		claw(-80);
	}
	claw(0);

	//wait 1/4 seconds
	wait10Msec(25);

	//clear encoders
	encoderclear();

	//arm down a little
	while (SensorValue[I2C_1] > -500)
	{
		arm(-80);
	}
	arm(5);

	//wait 1/2 seconds
	wait10Msec(50);

	//drive up a little
	while (SensorValue[I2C_3] < 200)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);

	//close claw a little
	while (SensorValue[clawPot] < 2000)
	{
		claw(127);
	}
	claw(0);

	//drive to post corner
	while (SensorValue[I2C_4] < 2100)
	{
		drive(0, 0, -80);
	}
	drive(0, 0, 0);

	//move forward
	while (SensorValue[I2C_3] < 1200)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);


}

void hang_auto()
{

	//clear encoders
	encoderclear();

	//open claw and grab stars
	while (SensorValue[clawPot] < 2500)
	{
		claw(127);
	}
	claw(0);

	//drive forward, push stars to the 1-pt zone
	while (SensorValue[I2C_3] < 1200)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//pivot to align with the corner
	while (SensorValue[I2C_3] > -900)
	{
		drive(-80, 80, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//strafe to the right slightly
	while (SensorValue[I2C_2] < 200)
	{
		drive(0, 0, 80);
	}
	drive(0, 0, 0);

	//back up into the corner
	drive(-80, -80, 0);
	wait10Msec(50);
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//adjust position
	while (SensorValue[I2C_3] < 100)
	{
		drive(60, 60, 0);
	}
	drive(0, 0, 0);
	wait10Msec(10);
	drive(-60, -60, 0);
	wait10Msec(30);
	drive(0, 0, 0);

	//hang!
	while (SensorValue[I2C_1] < 1250)
	{
		arm(127);
	}
	arm(0);
	wait10Msec(10);
	while (SensorValue[I2C_1] > 0)
	{
		arm(-127);
		drive(80, 80, 0);
	}
	drive(0, 0, 0);
	arm(0);

	//lock claw
	while (SensorValue[clawPot] > 450)
	{
		claw(-80);
	}
	claw(0);

}

void auto(bool left)
{

	//clear encoders
	encoderclear();

	//drives forward to the cube
	while (SensorValue[I2C_3] < 1400)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();
	//wait 1/4 seconds
	wait10Msec(25);

	//grab the cube
	claw(127);
	//wait 1 second
	wait10Msec(100);

	//if arm crosses itself, uncross
	if (SensorValue[clawPot] > 3700)
	{
		while (SensorValue[clawPot] > 3600)
		{
			claw(-100);
		}
		claw(0);
	}

	//lift the cube slightly
	while (SensorValue[I2C_1] < 300)
	{
		arm(100);
	}
	arm(40);

	//clear encoders
	encoderclear();

	//drive forward to line up with middle fence
	while (SensorValue[I2C_3] < 400)
	{
		drive(80, 80, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//turn so back faces the fence
	if (left)
	{
		while (SensorValue[I2C_3] < 700)
		{
			drive(80, -80, 0);
		}
		drive(0, 0, 0);
	}
	else
	{
		while (SensorValue[I2C_3] > -700)
		{
			drive(-80, 80, 0);
		}
		drive(0, 0, 0);
	}

	//clear encoders
	encoderclear();
	//wait 1/4 seconds
	wait10Msec(25);

	//drive up to fence and square up
	drive(-80, -80, 0);
	wait10Msec(175);
	drive(0, 0, 0);

	//lift arm, hit middle stars
	while (SensorValue[I2C_1] < 1250)
	{
		arm(127);
	}
	arm(0);

	//release cube
	while (SensorValue[clawPot] > 2200)
	{
		claw(-80);
	}
	claw(0);

	//wait 1/4 seconds
	wait10Msec(25);

	//bring arm down
	while (SensorValue[I2C_1] > -300)
	{
		arm(-127);
	}
	arm(0);

	//clear encoders
	encoderclear();

	//drive up to the 3 stars
	while (SensorValue[I2C_3] < 1400)
	{
		drive(127, 127, 0);
	}
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//grab the 3 stars
	while (SensorValue[clawPot] < 3200)
	{
		claw(127);
	}
	claw(100);

	//drive backwards slightly
	while (SensorValue[I2C_3] > -200)
	{
		drive(-80, -80, 0);
	}
	drive(0, 0, 0);

	//drive back to the fence and square up
	drive(-80, -80, 0);
	arm(50);
	wait10Msec(200);
	drive(0, 0, 0);

	//clear encoders
	encoderclear();

	//lift arm
	while (SensorValue[I2C_1] < 1250)
	{
		arm(127);
	}
	arm(0);

	//release stars
	while (SensorValue[clawPot] > 2200)
	{
		claw(-80);
	}
	claw(0);
}

task autonomous()
{
	if (SensorValue[autoButton] == 1)
	{
		auto(true);
	}
	else if (SensorValue[autoButton] == 0)
	{
		auto(false);
	}
}

task usercontrol()
{

	encoderclear();

	while (true)
	{
		motor[lbDrive] = motor[lfDrive] = vexRT[Ch3];
		motor[rbDrive] = motor[rfDrive] = vexRT[Ch2];
		motor[lMid] = motor[rMid] = vexRT[Ch4];


		if (vexRT[Btn6U] == 1)
		{
			if (SensorValue[clawPot] > 3500)
			{
				claw(50);
			}
			else
			{
				claw(127);
			}
		}
		else if (vexRT[Btn6D] == 1)
		{
			if (SensorValue[clawPot] > 2200)
			{
				while (vexRT[Btn6D] == 1)
				{
					claw(-127);
				}
				claw(0);
			}
		}
		else if (vexRT[Btn8U] == 1)
		{
			while (SensorValue[clawPot] > 450)
			{
				claw(-127);
			}
		}
		else
		{
			if (SensorValue[clawPot] >= 3200)
			{
				claw(15);
			}
			else if(SensorValue[clawPot] > 2200 && SensorValue[clawPot] < 3200)
			{
				claw(-1);
			}
		}

		if (vexRT[Btn5U] == 1)
		{
			arm(127);
		}
		else if (vexRT[Btn5D] == 1)
		{
			arm(-127);
		}
		else
		{
			if (SensorValue[I2C_1] > 120)
			{
				arm(10);
			}
			else
			{
				arm(-15);
			}
		}

	}
}
