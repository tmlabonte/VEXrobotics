#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl4,  left_quad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  right_quad,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           belt,          tmotorVex393, openLoop)
#pragma config(Motor,  port2,           top_wheel,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           shooter_top,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           shooter_middle, tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port5,           shooter_bottom, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           left_drive,    tmotorVex393, openLoop)
#pragma config(Motor,  port9,           right_drive,   tmotorVex393, openLoop, reversed, encoder, encoderPort, dgtl6, 1000)
#pragma config(Motor,  port10,          intake,        tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition control and duration settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(60)

//Main competition background code
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------*/
/* @brief        Global variable initialization                  */
/*---------------------------------------------------------------*/

//Battery voltage value for testing
long battery;

//Encoder values
long top_encoder;
long top_encoder_last;

//Motor velocities
float top_motor_velocity;
int back_pwr;

//Top wheel velocity
float top_wheel_velocity;

//TBH variables
int target_velocity;
float top_error_current;
float top_error_last;
float change;
float TBH;
float TBH_approx;
float TBH_zero;
int top_motor_pwr;

/*---------------------------------------------------------------*/
/* @brief        Set the shooter motors                          */
/* @param(in)    Desired front wheel power (3 motors)            */
/* @param(in)    Desired top wheel power (1 motor)				   		 */
/*---------------------------------------------------------------*/
void shootpwr(int front, int back)
{
	motor[shooter_top] = motor[shooter_middle] = motor[shooter_bottom] = front;
	motor[top_wheel] = back;
}

/*---------------------------------------------------------------*/
/* @brief        Set the drive motors                            */
/* @param(in)    Desired left side power                         */
/* @param(in)    Desired right side power         						   */
/*---------------------------------------------------------------*/
void drivepwr(int right, int left)
{
	motor[left_drive] = left;
	motor[right_drive] = right;
}

/*---------------------------------------------------------------*/
/* @brief        Set the roller motor                            */
/* @param(in)    Desired motor power                             */
/*---------------------------------------------------------------*/
void intakepwr(int pwr)
{
	motor[intake] = pwr;
}

/*---------------------------------------------------------------*/
/* @brief        Set the chain motor                             */
/* @param(in)    Desired motor power                             */
/*---------------------------------------------------------------*/
void beltpwr(int pwr)
{
	motor[belt] = pwr;
}

/*---------------------------------------------------------------*/
/* @brief        Clear encoder values                            */
/*---------------------------------------------------------------*/
void encoderclear()
{
	SensorValue[I2C_1] = 0;
	SensorValue[left_quad] = 0;
	SensorValue[right_quad] = 0;
}

/*---------------------------------------------------------------*/
/* @brief        Drive control function                          */
/*---------------------------------------------------------------*/
void drivecontrol(int pwr)
{
	//If the robot is leaning left, adjust course to the right
	if (SensorValue[left_quad] < SensorValue[right_quad])
	{
		drivepwr(pwr, pwr); //will change during comp
	}

	//If the robot is leaning right, adjust course to the left
	else if (SensorValue[left_quad] > SensorValue[right_quad])
	{
		drivepwr(pwr , pwr); //will change during comp
	}

	//If the robot is moving straight, continue
	else if (SensorValue[left_quad] == SensorValue[right_quad])
	{
		drivepwr(pwr, pwr);
	}
}

/*---------------------------------------------------------------*/
/* @brief        Pre-autonomous function                         */
/*---------------------------------------------------------------*/
void pre_auton()
{
	bStopTasksBetweenModes = true;
}

/*---------------------------------------------------------------*/
/* @brief        Calculate the velocity (rpm) of the flywheel    */
/*---------------------------------------------------------------*/
void getVelocity()
{

	//Local variable initialization
	int top_dE;

	//Assign encoder values to a variable
	top_encoder = SensorValue(I2C_1);

	//Calculate change in encoder values since function was last run
	top_dE = (top_encoder - top_encoder_last);
	top_encoder_last = top_encoder;

	//Calculate top motor & top wheel velocities (rpm)
	top_motor_velocity = (top_dE / .0005) / 627.20;
	top_wheel_velocity = top_motor_velocity * 35;

}

/*---------------------------------------------------------------*/
/* @brief        Set the target flywheel velocity (rpm)          */
/* @param(in)    Target flywheel velocity                        */
/* @param(in)    Predicted value for TBH variable  						   */
/*---------------------------------------------------------------*/
void setVelocity(int target, int prediction)
{

	//Set target velocity
	target_velocity = target;

	//Calculate current error
	top_error_current = target_velocity - top_motor_velocity;
	top_error_last = top_error_current;

	//Set predicted TBH value
	TBH_approx = prediction;

	//Clear TBH-zero variable
	TBH_zero = 0;
}

/*---------------------------------------------------------------*/
/* @brief        Update TBH variables                            */
/*---------------------------------------------------------------*/
void updateTBH()
{

	//Calculate current error
	top_error_current = target_velocity - top_motor_velocity;

	//Calculate new control variable values
	TBH = TBH + (top_error_current * change);

	//Clip to range [0, 1]
	if (TBH > 1)
	{
		TBH = 1;
	}
	if (TBH < 0)
	{
		TBH = 0;
	}

	//Check for zero-cross
	if (sgn(top_error_current) != sgn(top_error_last))
	{
		//Take back half
		TBH = 0.5 * (TBH + TBH_zero);

		//Update TBH variable
		TBH_zero = TBH;
	}

	//Save last error value
	top_error_last = top_error_current;

}

/*---------------------------------------------------------------*/
/* @brief        Velocity control task                           */
/*---------------------------------------------------------------*/
task velocitycontrol()
{

	change = 0.00025; //Controls speed and accuracy of the TBH normalization process

	while (true)
	{
		//Calculate current drive motor velocity
		getVelocity();

		//Update TBH variables
		updateTBH();

		//Scale TBH variables into the range [0, 127]
		top_motor_pwr = (TBH * 127) + 0.5;

		//Send calculated power value to the motors
		shootpwr(top_motor_pwr, back_pwr);

		//Wait 30 ms
		wait10Msec(3);

	}
}

/*---------------------------------------------------------------*/
/* @brief        Intake roller task for tap control              */
/*---------------------------------------------------------------*/
task in()
{
	intakepwr(70);
}

/*---------------------------------------------------------------*/
/* @brief        Battery voltage calculation task for testing    */
/*---------------------------------------------------------------*/
task batterylevel()
{
	while (true)
	{
		battery = nAvgBatteryLevel;
	}
}

/*---------------------------------------------------------------*/
/* @brief        Consolidation of start functions                */
/*---------------------------------------------------------------*/
void setup()
{

	//Clear encoders
	encoderclear();

	//Stop top back wheel
	back_pwr = 0;

	//Start velocity control task
	//StartTask(velocitycontrol);

	//Start battery voltage calculation task
	StartTask(batterylevel);

}

/*---------------------------------------------------------------*/
/* @brief        Main autonomous task                            */
/*---------------------------------------------------------------*/
task autonomous()
{

	//Various start functions
	setup();

	//Start the shooter
	//back_pwr = 127;
	shootpwr(127, 127);

	//Drive straight to the second ball while intaking
	while (SensorValue[left_quad] < 900)
	{
		drivepwr(48, 50);
		intakepwr(127);
		beltpwr(60);
	}

	//Drive straight to the fifth ball while intaking
	while (SensorValue[left_quad] < 2000)
	{
		drivepwr(48, 50);
		intakepwr(127);
		beltpwr(127);
	}

	//Stop drive and intake roller
	drivepwr(0, 0);
	intakepwr(0);

	//Shoot four balls
	beltpwr(127);
	wait10Msec(900);
	shootpwr(80, 127);

	//Drive straight to the bar while intaking
	while (SensorValue[left_quad] < 3300)
	{
		drivepwr(48, 50);
		intakepwr(127);
		beltpwr(127);
	}

	//Make sure the robot ends up straight
	while (SensorValue[left_quad] < 3500)
	{
		drivepwr(48, 50); //will change during comp
		intakepwr(127);
		beltpwr(127);
	}

	//Intake the seventh ball and align with the bar
	beltpwr(127);
	wait10Msec(50);

	//Stop the intake and drive
	intakepwr(0);
	drivepwr(0, 0);

	//Shoot three balls, then stop the shooter and belt
	wait10Msec(5000);
	beltpwr(0);
	setVelocity(0, 0);
	back_pwr = 0;

	////Realign with the bar
	//drivepwr(-30, -30);
	//wait10Msec(30);
	//drivepwr(30, 30);
	//wait10Msec(30);
	//drivepwr(0, 0);

	////Clear encoders
	//encoderclear();

	////Drive backwards 1/3 of a rotation
	//while (SensorValue[right_quad] < 120)
	//{
	//	drivepwr(-30, -30);
	//}
	//drivepwr(0, 0);

	////Clear encoders
	//encoderclear();
	//wait10Msec(50);

	////90 degree turn to the left
	//while (SensorValue[right_quad] > -190)
	//{
	//	drivepwr(-60, 50);
	//}
	//drivepwr(0, 0);

	////Clear encoders
	//encoderclear();
	//wait10Msec(50);

	////Drive forward and intake three balls
	//while (SensorValue[right_quad] < 900)
	//{
	//	drivepwr(45, 45); //will change during comp
	//	intakepwr(127);
	//	beltpwr(127);
	//}

	////Stop drive, intake roller, and belt
	//drivepwr(0, 0);
	//intakepwr(0);
	//beltpwr(0);

	////Clear encoders and start shooter
	//encoderclear();
	//setVelocity(65, 0.35);
	//back_pwr = 127;
	//wait10Msec(50);

	////45 degree turn to the right
	//while (SensorValue[left_quad] > -95)
	//{
	//	drivepwr(50, -60);
	//}

	////Stop drive
	//drivepwr(0, 0);

	////Shoot three balls
	//beltpwr(50);
	//intakepwr(127);
	//wait10Msec(1300);

	////Stop all subsystems
	//beltpwr(0);
	//intakepwr(0);
	//setVelocity(0, 0);
	//back_pwr = 0;

}

/*---------------------------------------------------------------*/
/* @brief        Main user control task                          */
/*---------------------------------------------------------------*/
task usercontrol()
{

	//Various start functions
	setup();
	StartTask(velocitycontrol);

	while (true)
	{

		//Map drive to joysticks
		motor[left_drive] = 0.9 * vexRT[Ch2];
		motor[right_drive] = 0.9 * vexRT[Ch3];

		//Map shooter to buttons (hold control)
		if (vexRT[Btn6U] == 1)
		{
			shootpwr(82, 100); //Moderate power (layup)
		}
		else if (vexRT[Btn6D] == 1)
		{
			shootpwr(127, 100); //Boosted power to normalize velocity after a shot
		}
		else
		{
			shootpwr(0, 0); //Zero power
		}

		//Map intake to buttons (tap control)
		if (vexRT[Btn7D] == 1)
		{
			StartTask(in); //Start intake task
		}
		else if (vexRT[Btn7L] == 1)
		{
			StopTask(in); //Stop intake task
			intakepwr(0); //Stop intake
		}

		//Map belt to buttons (hold control)
		if (vexRT[Btn5U] == 1)
		{
			beltpwr(127); //Maximum intake power
		}
		else if (vexRT[Btn5D] == 1)
		{
			beltpwr(-127); //Maximum outtake power
		}
		else
		{
			beltpwr(0); //Zero power
		}

	}

}
