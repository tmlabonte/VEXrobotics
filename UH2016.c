#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  autoButton,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           lbDrive,       tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port2,           lfDrive,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port3,           lbArm,         tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port4,           ltArm,         tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port5,           lClaw,         tmotorVex393, openLoop)
#pragma config(Motor,  port6,           rClaw,         tmotorVex393, openLoop)
#pragma config(Motor,  port7,           rtArm,         tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port8,           rbArm,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port9,           rfDrive,       tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port10,          rbDrive,       tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


void encoderclear()
{
	SensorValue[I2C_1] = SensorValue[I2C_2] = SensorValue[I2C_3] = 0;
}


void drive(int left, int right)
{
	motor[lbDrive] = motor[lfDrive] = left;
	motor[rbDrive] = motor[rfDrive] = right;
}


void claw(int pwr)
{
	motor[lClaw] = motor[rClaw] = pwr;
}


void arm(int pwr)
{
	motor[lbArm] = motor[ltArm] = motor[rbArm] = motor[rtArm] = pwr;
}


void pre_auton()
{
	bStopTasksBetweenModes = true;
}




void auto(bool left)
{

	//clear encoders
	encoderclear();


	//drives forward to the cube
	while (SensorValue[I2C_1] < 1200)
	{
		drive(80, 80);
	}
	drive(0, 0);


	//clear encoders
	encoderclear();
	//wait 1/4 seconds
	wait10Msec(25);


	//grab the cube
	claw(127);
	//wait 1 second
	wait10Msec(100);


	//if arm crosses itself, uncross
	if (SensorValue[clawPot] > 3700)
	{
		while (SensorValue[clawPot] > 3600)
		{
			claw(-100);
		}
		claw(0);
	}


	//lift the cube slightly
	while (SensorValue[I2C_3] < 300)
	{
		arm(100);
	}
	arm(40);


	//clear encoders
	encoderclear();


	//drive forward to line up with middle fence
	while (SensorValue[I2C_1] < 400)
	{
		drive(80, 80);
	}
	drive(0, 0);


	//clear encoders
	encoderclear();


	//turn so back faces the fence
	if (left)
	{
		while (SensorValue[I2C_1] < 500)
		{
			drive(80, -80);
		}
		drive(0, 0);
	}
	else
	{
		while (SensorValue[I2C_1] > -500)
		{
			drive(-80, 80);
		}
		drive(0, 0);
	}


	//clear encoders
	encoderclear();
	//wait 1/4 seconds
	wait10Msec(25);


	//drive up to fence and square up
	drive(-80, -80);
	wait10Msec(150);
	drive(0, 0);


	//lift arm, hit middle stars
	while (SensorValue[I2C_3] < 700)
	{
		arm(127);
	}
	arm(0);


	//release cube
	while (SensorValue[clawPot] > 2200)
	{
		claw(-80);
	}
	claw(0);


	//wait 1/4 seconds
	wait10Msec(25);


	//bring arm down
	while (SensorValue[I2C_3] > -300)
	{
		arm(-127);
	}
	arm(0);


	//clear encoders
	encoderclear();


	////drive up to the 3 stars
	//while (SensorValue[I2C_1] < 1400)
	//{
	//	drive(127, 127);
	//}
	//drive(0, 0);


	////clear encoders
	//encoderclear();


	////grab the 3 stars
	//claw(100);
	//wait10Msec(50);

	////drive backwards slightly
	//while (SensorValue[I2C_1] > -200)
	//{
	//	drive(-80, -80);
	//}
	//drive(0, 0);


	////drive back to the fence and square up
	//drive(-80, -80);
	//arm(50);
	//wait10Msec(200);
	//drive(0, 0);


	////clear encoders
	//encoderclear();


	////lift arm
	//while (SensorValue[I2C_3] < 700)
	//{
	//	arm(127);
	//}
	//arm(0);


	////release stars
	//while (SensorValue[clawPot] > 2200)
	//{
	//	claw(-80);
	//}
	//claw(0);
}


task autonomous()
{
	if (SensorValue[autoButton] == 1)
	{
		auto(true);
	}
	else
	{
		auto(false);
	}
}


task usercontrol()
{
	//clear encoders
	encoderclear();

	while (true)
	{
		motor[lbDrive] = motor[lfDrive] = vexRT[Ch3];
		motor[rbDrive] = motor[rfDrive] = vexRT[Ch2];

		//buttons for control of claw
		if (vexRT[Btn6U] == 1)
		{
			if (SensorValue[clawPot] > 3500)
			{
				claw(70);
			}
			else
			{
				claw(100);
			}
		}
		else if (vexRT[Btn6D] == 1)
		{
			if (SensorValue[clawPot] > 2200)
			{
				while (vexRT[Btn6D] == 1)
				{
					claw(-100);
				}
				claw(0);
			}
		}
		else if (vexRT[Btn8U] == 1)
		{
			while (SensorValue[clawPot] > 450)
			{
				claw(-127);
			}
		}
		else
		{
			if (SensorValue[clawPot] >= 3200)
			{
				claw(15);
			}
			else if(SensorValue[clawPot] > 2200 && SensorValue[clawPot] < 3200)
			{
				claw(-1);
			}
		}

		//buttons for control of arm
		if (vexRT[Btn5U] == 1)
		{
			arm(127);
		}
		else if (vexRT[Btn5D] == 1)
		{
			arm(-127);
		}
		else
		{
			if (SensorValue[I2C_3] > 120)
			{
				arm(10);
			}
			else
			{
				arm(-15);
			}
		}


	}
}
