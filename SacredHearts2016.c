#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rBtn,           sensorTouch)
#pragma config(Sensor, dgtl2,  lBtn,           sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rBottom,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port2,           rTops,         tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           rMiddle,       tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           fRight,        tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port5,           bRight,        tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port6,           bLeft,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port7,           fLeft,         tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port8,           lTops,         tmotorVex393, openLoop)
#pragma config(Motor,  port9,           lMiddle,       tmotorVex393, openLoop)
#pragma config(Motor,  port10,          lBottom,       tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Function to clear encoders
void encoderclear()
{
	SensorValue[I2C_1] = SensorValue[I2C_2] = SensorValue[I2C_3] = SensorValue[I2C_4] = 0;
}

//Function for consolidation of arm motor commands
void armPwr(int pwr) //input desired power level
{
	//all arm motors are set to the same power
	motor[rTops] = motor[rMiddle] = motor[rBottom] = motor[lTops] = motor[lMiddle] = motor[lBottom] = pwr;
}

//Function for consolidation of drive commands
void drive(int left, int right) //input desired power levels
{
	motor[fLeft] = left;
	motor[bLeft] = -left;
	motor[fRight] = -right;
	motor[bRight] = right;
}

//Multi-function task to ensure arm...
//	Does not get stuck on the velcro,
//	Does not collapse under the weight of the game pieces, and
//	Does not overextend and break the potentiometer or flip
task trim()
{

	while (true)
	{

		//If the arm touches the buttons, jerk upwards so as to not get stuck on velcro
		if (SensorValue[rBtn] == 1 || SensorValue[lBtn] == 1)
		{
			while (SensorValue[armPot] > 3300)
			{
				armPwr(70);
			}
			armPwr(0);
		}

		//If the arm is in the normal range and no button is pressed, apply power to the arm
		else if (SensorValue[armPot] <= 3300 && SensorValue[armPot] > 1200 && vexRT[Btn5D] == 0 && vexRT[Btn5U] == 0 && vexRT[Btn6D] == 0 && vexRT[Btn6U] == 0)
		{
			armPwr(15);
		}

		//If the arm overextends, jerk down so as to not break potentiometer or flip
		else if (SensorValue[armPot] <= 1200)
		{
			armPwr(-127);
		}

	}

}

//Function for automation of hang during autonomous
void autoHang()
{
	StopTask(trim);

	armPwr(127);
	wait10Msec(50);

	armPwr(0);
	wait10Msec(10);

	armPwr(-127);
	drive(127, 127);
	wait10Msec(400);

	armPwr(0);
	drive(0, 0);
}

//Function for automation of hang during driver control
void driverHang()
{
	StopTask(trim);

	armPwr(-127);
	drive(127, 127);
	wait10Msec(400);

	armPwr(0);
	drive(0, 0);
}

//Function to get down from a hanging position
void getDown()
{
	armPwr(127);
	wait10Msec(25);
	armPwr(25);
	wait10Msec(200);
	armPwr(0);

	drive(-30, -30);
	armPwr(-100);
	wait10Msec(200);
	drive(0, 0);
	armPwr(0);
}


//Function for automation of throw
void throw()
{

	while (true)
	{
		if (SensorValue[armPot] > 1700)
		{
			armPwr(100);
		}
		else if (SensorValue[armPot] <= 1700)
		{
			armPwr(0);
			break;
		}
	}

}

//Function to return arm to resting position after throw
void returnArm()
{
	while (SensorValue[armPot] <= 3300)
	{
		armPwr(-60);
	}
	armPwr(0);
}

//Pre-autonomous variable setting
void pre_auton()
{
	//stop all robot tasks between autonomous and user control
	bStopTasksBetweenModes = true;
}

//Autonomous function with input for positions
void auto(bool left)
{

	//clear encoders
	encoderclear();

	//drive forward while raising arm, knock over two stars
	while (SensorValue[I2C_2] < 1150)
	{
		drive(127, 127);
		while (SensorValue[armPot] > 3200)
		{
			armPwr(127);
		}
		while (SensorValue[armPot] > 2050)
		{
			armPwr(51);
		}
		armPwr(0);
	}
	drive(0, 0);
	wait10Msec(20);
	encoderclear();

	//drive backwards
	while (SensorValue[I2C_2] > -250)
	{
		drive(-40, -40);
	}
	drive(0, 0);
	wait10Msec(20);
	encoderclear();

	//if started on the left, turn right; if started on the right, turn left
	if (left)
	{
		while (SensorValue[I2C_1] < 100)
		{
			drive(40, -40);
		}
	}
	else
	{
		while (SensorValue[I2C_1] > -100)
		{
			drive(-40, 40);
		}
	}
	drive(0, 0);
	wait10Msec(20);
	encoderclear();

	//if started on the left, drive right; if started on the right, drive left...knock over four stars
	if (left)
	{
		motor[fLeft] = motor[bRight] = 80;
	}
	else
	{
		motor[bLeft] = motor[fRight] = -80;
	}
	wait10Msec(350);
	drive(0, 0);
	wait10Msec(20);
	encoderclear();

}


task autonomous()
{
	auto(false);
}

task usercontrol()
{

	StartTask(trim);

	while (true)
	{

		//Controls movement of the drive
		motor[fLeft] = vexRT[Ch4] + vexRT[Ch3] + vexRT[Ch1];
		motor[bLeft] = vexRT[Ch4] - vexRT[Ch3] - vexRT[Ch1];
		motor[fRight] = vexRT[Ch4] - vexRT[Ch3] + vexRT[Ch1];
		motor[bRight] = vexRT[Ch4] + vexRT[Ch3] - vexRT[Ch1];

		//Maps manual up to button 5U
		if (vexRT[Btn5U] == 1)
		{
			armPwr(60);
		}

		//Maps manual down to button 5D
		else if (vexRT[Btn5D] == 1)
		{
			armPwr(-30);
		}

		//Maps throw to button 6U
		else if (vexRT[Btn6U] == 1)
		{
			armPwr(127);
		}

		//Maps automatic down to button 6D
		else if (vexRT[Btn6D] == 1)
		{
			while (SensorValue[armPot] <= 2200)
			{
				StopTask(trim);
				armPwr(-60);
			}
			StartTask(trim);
			armPwr(0);
		}

		//If no button is pressed, keep arm still
		else
		{
			armPwr(0);
		}

		//Maps deactivation of trim() to button 8D
		if (vexRT[Btn8D] == 1)
		{
			StopTask(trim);
		}

		//Maps activation of trim() to button 8R
		if (vexRT[Btn8R] == 1)
		{
			StartTask(trim);
		}

		//Maps hang function to button 7U
		if (vexRT[Btn7U] == 1)
		{
			driverHang();
		}

		//Maps getting down from hang function to button 7D
		if (vexRT[Btn7D] == 1)
		{
			getDown();
		}

		//Maps arm return to button 6D
		if (vexRT[Btn6D] == 1)
		{
			returnArm();
		}

	}
}
